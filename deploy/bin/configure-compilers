#!/bin/bash -eu

log() {
    echo "$@" >&2
}

. "${SPACK_ROOT}/share/spack/setup-env.sh"

if [[ -z "${1:-}" ]]; then
    if [[ -z "${SPACK_ENV:-}" ]]; then
        echo "usage: configure-compilers SPACK_ENV"
        echo "       configure-compilers  # with an active environment"
        exit 1
    fi
    # Nothing to do, a spack environment should be active
else
    spack env activate "${1}"
fi

while read -r line; do
    sha="${line%% *}"  # Remove everything after and including the first space
    spec="${line#* }"  # Remove everything up to and including the first space
    set +o nounset
    env_mods=""


    # Skip all but compilers. Compiler variants need to be specified
    # *after* the version specification!
    case "${spec}" in
        gcc@*)
            ;;
        intel@*)
            ;;
        intel-parallel-studio@*)
            ;;
        llvm@*)
            ;;
        nvhpc@*)
            ;;
        pgi@*)
            ;;
        *)
            continue
            ;;
    esac

    # When a compiler is compiled with *anything but the base
    # compiler*, it's module will not be generated in the initial
    # module refresh
    #
    # As the input should be sorted by compilers, the module generation
    # will now find the compilers that were used when bootstrapping.
    log "...processing ${line}"
    cmd=$(spack module tcl loads ${sha}|tail -n 1)
    echo "${cmd}"
    ${cmd}
    set -o nounset
    if [[ ${spec} != *"intel-parallel-studio"* ]]; then
        spack compiler find --scope=user
    fi

    # Find the location of *any* GCC, disregarding the environment that's
    # active (-E).  Prefer the hash passed through by earlier stages, if
    # not available fall back to the crude version.
    GCC_DIR=$(spack -E location --install-dir ${BASE_GCC_HASH:-gcc@${BASE_GCC_VERSION}})
    log "...using gcc ${BASE_GCC_VERSION} from ${GCC_DIR}"
    if [[ ${spec} = *"intel"* ]]; then
        # update intel modules to use newer gcc in .cfg files
        INTEL_DIR=$(spack location --install-dir ${sha})
        # we don't want to modify any files in the upstream deployment,
        # thus ensure that the installation directory is prefixed by our
        # deployment target
        if [[ "${INTEL_DIR}" != "${DEPLOYMENT_ROOT}"* ]]; then
            log "...installation does not match install prefix, skipping modification of files"
        fi
        for f in $(find ${INTEL_DIR} -name "icc.cfg" -o -name "icpc.cfg" -o -name "ifort.cfg"); do
            if ! grep -q "${GCC_DIR}" $f; then
                echo "-gcc-name=${GCC_DIR}/bin/gcc" >> ${f}
                echo "-Xlinker -rpath=${GCC_DIR}/lib" >> ${f}
                echo "-Xlinker -rpath=${GCC_DIR}/lib64" >> ${f}
                log "updated ${f} with newer GCC"
            fi
        done
    elif [[ ${line} = *"pgi"* || ${line} = *"nvhpc"* ]]; then
        #update pgi modules for network installation
        PGI_DIR=$(dirname $(which makelocalrc))
        PGI_TMPDIR=$(mktemp -d -p .)
        makelocalrc ${PGI_DIR} -d "${PGI_TMPDIR}" -gcc ${GCC_DIR}/bin/gcc -gpp ${GCC_DIR}/bin/g++ -g77 ${GCC_DIR}/bin/gfortran -x -net
        #configure pgi network license
        template=$(ls -rt "${PGI_TMPDIR}"/localrc* | tail -n 1)
        echo "set PREOPTIONS=-D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL=1;" >> "${template}"
        log "NVIDIA localrc template"
        cat "${template}"
        compute_nodes=$(sinfo -h -N -o %n | sort -u)
        # we don't want to modify any files in the upstream deployment,
        # thus ensure that the installation directory is prefixed by our
        # deployment target
        if [[ "${PGI_DIR}" != "${DEPLOYMENT_ROOT}"* ]]; then
            log "...installation does not match install prefix, skipping modification of files"
        else
            for node in bbpv1 bbpv2 bbptadm tds03 tds04 ${compute_nodes}; do
                cp $template $PGI_DIR/localrc.$node || true
            done
        fi
        rm -rf "${PGI_TMPDIR}"
    fi
    cmd=${cmd/load/unload}
    echo "${cmd}"
    ${cmd}

    cmd=${cmd/unload/show/}
    full_module_path="$(${cmd}|&sed -ne '2{s/:$// p}')"
    spec=${spec%%[+ ]*}             # truncate variants
    spec=${spec/llvm/clang}         # LLVM identifies as clang
    spec=${spec/20.0.2/19.1.2.254}  # Intel identifies as an older version
    # Remove empty module definitions, as they may appear anywhere
    # under the compiler key. Further, purge some garbage where clang's
    # spec spans multiple lines with a quote in front.
    #
    # After removing all unnecessary stuff, re-add the appropriate
    # module definition with a full path.
    sed -i -e '
        /modules: \[\]/ d;
        /^\s*Target:.\s*$/ d;
        /^\s*$/ d;
        s#spec: .clang#spec: clang#
        s#\( *\)spec: '"${spec}"'#&\n\1modules: ['"${full_module_path}"']#' ${HOME}/.spack/compilers.yaml
done

sed  -i 's#.*f\(77\|c\): null#      f\1: /usr/bin/gfortran#' ${HOME}/.spack/compilers.yaml
